/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@formio/lodash/lib/array.js":
/*!**************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/array.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.intersection = exports.map = exports.head = exports.last = exports.filter = exports.findEach = exports.matches = exports.findIndex = exports.find = exports.each = exports.dropRight = exports.drop = exports.difference = exports.concat = exports.compact = exports.chunk = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar object_1 = __webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\");\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\nfunction chunk(input, size) {\n    return input.reduce(function (arr, item, idx) {\n        return idx % size === 0\n            ? __spreadArray(__spreadArray([], arr, true), [[item]], false) : __spreadArray(__spreadArray([], arr.slice(0, -1), true), [__spreadArray(__spreadArray([], arr.slice(-1)[0], true), [item], false)], false);\n    }, []);\n}\nexports.chunk = chunk;\n;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_compact\nfunction compact(input) {\n    return input.filter(Boolean);\n}\nexports.compact = compact;\n/**\n * @link https://lodash.com/docs/4.17.15#concat\n * @param input\n * @param args\n * @returns\n */\nfunction concat(input) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return input.concat.apply(input, args);\n}\nexports.concat = concat;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_difference\nfunction difference() {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    return arrays.reduce(function (a, b) {\n        return a.filter(function (value) {\n            return !b.includes(value);\n        });\n    });\n}\nexports.difference = difference;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_drop\nfunction drop(arr, index) {\n    if (index === void 0) { index = 1; }\n    return (index > 0) ? arr.slice(index) : arr;\n}\nexports.drop = drop;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_dropright\nfunction dropRight(arr, index) {\n    if (index === void 0) { index = 1; }\n    return (index > 0) ? arr.slice(0, -index) : arr;\n}\nexports.dropRight = dropRight;\n/**\n * Iterate through a collection or array.\n * @param collection\n * @param _each\n */\nfunction each(collection, _each) {\n    var isArray = Array.isArray(collection);\n    for (var i in collection) {\n        if (collection.hasOwnProperty(i)) {\n            if (_each(collection[i], isArray ? Number(i) : i) === true) {\n                break;\n            }\n            ;\n        }\n    }\n}\nexports.each = each;\n/**\n * Perform a find operation.\n * @param arr\n * @param query\n */\nfunction find(arr, query, findIndex) {\n    if (findIndex === void 0) { findIndex = false; }\n    if (!arr) {\n        return undefined;\n    }\n    if (Array.isArray(arr) && typeof query === 'function') {\n        return findIndex ? arr.findIndex(query) : arr.find(query);\n    }\n    var found = undefined;\n    var foundIndex = 0;\n    findEach(arr, query, function (item, index) {\n        found = item;\n        foundIndex = index;\n        return true;\n    });\n    return findIndex ? foundIndex : found;\n}\nexports.find = find;\n/**\n * Find an index.\n *\n * @param arr\n * @param query\n * @returns\n */\nfunction findIndex(arr, query) {\n    return find(arr, query, true);\n}\nexports.findIndex = findIndex;\n/**\n * Returns a function to perform matches.\n * @param query\n * @returns\n */\nfunction matches(query) {\n    var keys = [];\n    var compare = {};\n    if (typeof query === 'string') {\n        keys = [query];\n        compare[query] = true;\n    }\n    else {\n        keys = Object.keys(query);\n        compare = query;\n    }\n    return function (comp) {\n        return (0, lang_1.isEqual)((0, object_1.pick)(comp, keys), compare);\n    };\n}\nexports.matches = matches;\n/**\n * Perform a find operation on each item in an array.\n * @param arr\n * @param query\n * @param fn\n */\nfunction findEach(arr, query, fn) {\n    each(arr, function (item, index) {\n        if (matches(query)(item)) {\n            if (fn(item, index) === true) {\n                return true;\n            }\n        }\n    });\n}\nexports.findEach = findEach;\n/**\n * Perform a filter operation.\n * @param arr\n * @param fn\n */\nfunction filter(arr, fn) {\n    if (!arr) {\n        return [];\n    }\n    if (!fn) {\n        fn = function (val) { return !!val; };\n    }\n    if (Array.isArray(arr) && typeof fn === 'function') {\n        return arr.filter(fn);\n    }\n    var found = [];\n    findEach(arr, fn, function (item, index) {\n        found.push(item);\n        if (Array.isArray(item)) {\n            arr.splice(index, 1);\n        }\n        else {\n            delete arr[index];\n        }\n    });\n    return found;\n}\nexports.filter = filter;\n/**\n * Get the last item in an array.\n * @param arr\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexports.last = last;\n/**\n * https://lodash.com/docs/4.17.15#head\n * @param arr\n * @returns\n */\nfunction head(arr) {\n    return arr[0];\n}\nexports.head = head;\n/**\n * https://lodash.com/docs/4.17.15#map\n * @param arr\n * @param fn\n * @returns\n */\nfunction map(arr, fn) {\n    return arr.map(fn);\n}\nexports.map = map;\n/**\n * Get the intersection of two objects.\n * @param a\n * @param b\n */\nfunction intersection(a, b) {\n    return a.filter(function (value) { return b.includes(value); });\n}\nexports.intersection = intersection;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/array.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/function.js":
/*!*****************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/function.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.debounce = void 0;\n/**\n * Debounc the call of a function for a given amount of time.\n *\n * @param func\n * @param wait\n * @returns\n */\nfunction debounce(func, wait) {\n    if (wait === void 0) { wait = 100; }\n    var timeout;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(function () {\n            timeout = null;\n            func.apply(void 0, args);\n        }, wait);\n    };\n}\nexports.debounce = debounce;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/function.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chain = void 0;\nvar ArrayFunctions = __importStar(__webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\"));\nvar Chainable = /** @class */ (function () {\n    function Chainable(val) {\n        this.chain = [];\n        this.currentValue = [];\n        this.currentValue = val;\n    }\n    Chainable.prototype.value = function () {\n        return this.chain.reduce(function (current, func) {\n            var _a;\n            return (_a = ArrayFunctions)[func.method].apply(_a, __spreadArray([current], func.args, false));\n        }, this.currentValue);\n    };\n    return Chainable;\n}());\nvar _loop_1 = function (method) {\n    if (ArrayFunctions.hasOwnProperty(method)) {\n        Chainable.prototype[method] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            this.chain.push({ method: method, args: args });\n            return this;\n        };\n    }\n};\nfor (var method in ArrayFunctions) {\n    _loop_1(method);\n}\n/**\n * Create a chainable array of methods.\n * @param val\n * @returns\n */\nfunction chain(val) {\n    return new Chainable(val);\n}\nexports.chain = chain;\nexports[\"default\"] = chain;\n__exportStar(__webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function */ \"./node_modules/@formio/lodash/lib/function.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\"), exports);\n__exportStar(__webpack_require__(/*! ./math */ \"./node_modules/@formio/lodash/lib/math.js\"), exports);\n__exportStar(__webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\"), exports);\n__exportStar(__webpack_require__(/*! ./string */ \"./node_modules/@formio/lodash/lib/string.js\"), exports);\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/index.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/lang.js":
/*!*************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/lang.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isRegExp = exports.isBoolean = exports.isNumber = exports.isPlainObject = exports.isObject = exports.isObjectLike = exports.isArray = exports.isNull = exports.isNil = exports.isNaN = exports.isInteger = exports.isEmpty = exports.isString = exports.isEqual = exports.noop = void 0;\nvar array_1 = __webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\");\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n/**\n * A no-operation function.\n */\nfunction noop() {\n    return;\n}\nexports.noop = noop;\n;\n/**\n * Determines equality of a value or complex object.\n * @param a\n * @param b\n */\nfunction isEqual(a, b) {\n    var equal = false;\n    if (a === b) {\n        return true;\n    }\n    if (a && b && (Array.isArray(a) || isObject(a)) && Object.keys(a).length === Object.keys(b).length) {\n        equal = true;\n        (0, array_1.each)(a, function (val, key) {\n            if ((Array.isArray(val) || isObject(val)) && !isEqual(b[key], val)) {\n                equal = false;\n                return true;\n            }\n            if (b[key] !== val) {\n                equal = false;\n                return true;\n            }\n        });\n    }\n    return equal;\n}\nexports.isEqual = isEqual;\nfunction isString(val) {\n    return typeof val === 'string';\n}\nexports.isString = isString;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\nfunction isEmpty(val) {\n    return [Object, Array].includes((val || {}).constructor) && !Object.entries((val || {})).length;\n}\nexports.isEmpty = isEmpty;\nfunction isInteger(val) {\n    return Number.isInteger(val);\n}\nexports.isInteger = isInteger;\nfunction isNaN(val) {\n    return Number.isNaN(val);\n}\nexports.isNaN = isNaN;\nfunction isNil(val) {\n    return val == null;\n}\nexports.isNil = isNil;\nfunction isNull(val) {\n    return val === null;\n}\nexports.isNull = isNull;\nfunction isArray(val) {\n    return Array.isArray(val);\n}\nexports.isArray = isArray;\nfunction isObjectLike(val) {\n    return typeof val === 'object' && (val !== null);\n}\nexports.isObjectLike = isObjectLike;\nfunction isObject(val) {\n    var type = typeof val;\n    return val != null && (type === 'object' || type === 'function');\n}\nexports.isObject = isObject;\nfunction isPlainObject(value) {\n    if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    var proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n}\nexports.isPlainObject = isPlainObject;\nfunction isNumber(val) {\n    return typeof val === 'number' || (isObjectLike(val) && getTag(val) == '[object Number]');\n}\nexports.isNumber = isNumber;\nfunction isBoolean(val) {\n    return val === true || val === false || (isObjectLike(val) && getTag(val) == '[object Boolean]');\n}\nexports.isBoolean = isBoolean;\nfunction isRegExp(val) {\n    return isObjectLike(val) && getTag(val) == '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/lang.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/math.js":
/*!*************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/math.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sumBy = exports.sum = exports.mod = exports.subtract = exports.round = exports.multiply = exports.minBy = exports.min = exports.meanBy = exports.mean = exports.maxBy = exports.max = exports.floor = exports.divide = exports.ceil = exports.add = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar object_1 = __webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\");\nfunction mathOp(a, op, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (!precision) {\n        return op(a);\n    }\n    precision = Math.pow(10, precision);\n    return op(a * precision) / precision;\n}\nfunction compareBy(arr, fn, op) {\n    var first = arr[0];\n    if (arr.length <= 1) {\n        return first;\n    }\n    var fnString = (0, lang_1.isString)(fn);\n    return arr.slice(1).reduce(function (current, next) {\n        var currentValue = fnString ? (0, object_1.get)(current, fn) : fn(current);\n        var nextValue = fnString ? (0, object_1.get)(next, fn) : fn(next);\n        var result = op(currentValue, nextValue);\n        return (result === nextValue) ? next : current;\n    }, first);\n}\nfunction valueBy(arr, fn, op) {\n    var first = arr[0];\n    if (arr.length <= 1) {\n        return first;\n    }\n    var fnString = (0, lang_1.isString)(fn);\n    return arr.slice(1).reduce(function (current, next) { return op(current, fnString ? (0, object_1.get)(next, fn) : fn(next)); }, fnString ? (0, object_1.get)(first, fn) : fn(first));\n}\n/**\n * @link https://lodash.com/docs/4.17.15#add\n * @param augend\n * @param addend\n * @returns\n */\nfunction add(augend, addend) {\n    return augend + addend;\n}\nexports.add = add;\n/**\n * @link https://lodash.com/docs/4.17.15#ceil\n * @param num\n * @param precision\n * @returns\n */\nfunction ceil(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.ceil, precision);\n}\nexports.ceil = ceil;\n/**\n * https://lodash.com/docs/4.17.15#divide\n * @param dividend\n * @param divisor\n * @returns\n */\nfunction divide(dividend, divisor) {\n    return dividend / divisor;\n}\nexports.divide = divide;\n/**\n * @link https://lodash.com/docs/4.17.15#floor\n * @param num\n * @param precision\n * @returns\n */\nfunction floor(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.floor, precision);\n}\nexports.floor = floor;\n/**\n * @link https://lodash.com/docs/4.17.15#max\n * @param arr\n * @returns\n */\nfunction max(arr) {\n    return Math.max.apply(Math, arr);\n}\nexports.max = max;\n/**\n * @link https://lodash.com/docs/4.17.15#maxBy\n */\nfunction maxBy(arr, fn) {\n    return compareBy(arr, fn, Math.max);\n}\nexports.maxBy = maxBy;\n/**\n * @link https://lodash.com/docs/4.17.15#mean\n * @param arr\n * @returns\n */\nfunction mean(arr) {\n    return sum(arr) / arr.length;\n}\nexports.mean = mean;\n/**\n * @link https://lodash.com/docs/4.17.15#meanBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction meanBy(arr, fn) {\n    return sumBy(arr, fn) / arr.length;\n}\nexports.meanBy = meanBy;\n/**\n * @link https://lodash.com/docs/4.17.15#min\n * @param arr\n * @returns\n */\nfunction min(arr) {\n    return Math.min.apply(Math, arr);\n}\nexports.min = min;\n/**\n * @link https://lodash.com/docs/4.17.15#minBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction minBy(arr, fn) {\n    return compareBy(arr, fn, Math.min);\n}\nexports.minBy = minBy;\n/**\n * @link https://lodash.com/docs/4.17.15#multiply\n * @param multiplier\n * @param multiplicand\n * @returns\n */\nfunction multiply(multiplier, multiplicand) {\n    return multiplier * multiplicand;\n}\nexports.multiply = multiply;\n/**\n * @link https://lodash.com/docs/4.17.15#round\n * @param num\n * @param precision\n * @returns\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.round, precision);\n}\nexports.round = round;\n/**\n * @link https://lodash.com/docs/4.17.15#subtract\n * @param a\n * @param b\n * @returns\n */\nfunction subtract(minuend, subtrahend) {\n    return minuend - subtrahend;\n}\nexports.subtract = subtract;\n/**\n * Perform a modulus operation between two numbers.\n * @param a\n * @param b\n * @returns\n */\nfunction mod(a, b) {\n    return a % b;\n}\nexports.mod = mod;\n/**\n * @link https://lodash.com/docs/4.17.15#sum\n * @param arr\n * @returns\n */\nfunction sum(arr) {\n    return arr.reduce(add, 0);\n}\nexports.sum = sum;\n/**\n * @link https://lodash.com/docs/4.17.15#sumBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction sumBy(arr, fn) {\n    return valueBy(arr, fn, function (a, b) { return (a + b); });\n}\nexports.sumBy = sumBy;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/math.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/object.js":
/*!***************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/object.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pick = exports.defaults = exports.cloneDeep = exports.clone = exports.fastCloneDeep = exports.merge = exports.set = exports.has = exports.propertyOf = exports.property = exports.get = exports.pathParts = exports.values = exports.keys = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar array_1 = __webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\");\n/**\n * Get the keys of an Object.\n * @param obj\n */\nfunction keys(obj) {\n    return Object.keys(obj);\n}\nexports.keys = keys;\n;\n/**\n * Return the values of an object or an array.\n * @param obj\n * @returns\n */\nfunction values(obj) {\n    return (0, lang_1.isArray)(obj) ? obj : Object.values(obj);\n}\nexports.values = values;\n/**\n * Retrieve the path parts provided a path string.\n * @param path\n */\nfunction pathParts(path) {\n    if (!path) {\n        return [];\n    }\n    if (path[0] === '[') {\n        path = path.replace(/^\\[([^\\]]+)\\]/, '$1');\n    }\n    return path.\n        replace(/\\[/g, '.').\n        replace(/\\]/g, '').\n        split('.');\n}\nexports.pathParts = pathParts;\n/**\n * Get the value from an object or an array provided a path.\n *\n * @param obj\n * @param path\n * @param def\n */\nfunction get(obj, path, def) {\n    var val = pathParts(path).reduce(function (o, k) { return (o || {})[k]; }, obj);\n    return (typeof def !== 'undefined' &&\n        typeof val === 'undefined') ? def : val;\n}\nexports.get = get;\nfunction property(path) {\n    return function (obj) { return get(obj, path); };\n}\nexports.property = property;\nfunction propertyOf(obj) {\n    return function (path) { return get(obj, path); };\n}\nexports.propertyOf = propertyOf;\n/**\n * Determine if a value is set.\n *\n * @param obj\n * @param path\n */\nfunction has(obj, path) {\n    return get(obj, path, undefined) !== undefined;\n}\nexports.has = has;\n/**\n * Sets the value of an item within an array or object.\n * @param obj\n * @param path\n * @param value\n */\nfunction set(obj, path, value) {\n    var parts = pathParts(path);\n    parts.reduce(function (o, k, i) {\n        if (!isNaN(Number(k))) {\n            k = Number(k);\n        }\n        if ((Array.isArray(o) ? (k >= o.length) : !o.hasOwnProperty(k)) ||\n            ((i < (parts.length - 1)) && !Array.isArray(o[k]) && !(0, lang_1.isObject)(o[k]))) {\n            o[k] = !isNaN(Number(parts[i + 1])) ? [] : {};\n        }\n        if (i === (parts.length - 1)) {\n            o[k] = value;\n        }\n        return o[k];\n    }, obj);\n    return obj;\n}\nexports.set = set;\n;\nfunction propertyIsOnObject(object, property) {\n    try {\n        return property in object;\n    }\n    catch (_) {\n        return false;\n    }\n}\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\n/**\n * Merge a single object.\n *\n * @param target\n * @param source\n * @returns\n */\nfunction mergeObject(target, source) {\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            if (propertyIsUnsafe(target, key)) {\n                return;\n            }\n            if (propertyIsOnObject(target, key)) {\n                target[key] = merge(target[key], source[key]);\n            }\n            else {\n                target[key] = cloneDeep(source[key]);\n            }\n        }\n    }\n    return target;\n}\n/**\n * Merge two arrays.\n * @param target\n * @param source\n */\nfunction mergeArray(target, source) {\n    source.forEach(function (subSource, index) {\n        target[index] = merge(target[index], subSource);\n    });\n    return target;\n}\n/**\n * Merges a complex data object.\n *\n * @param a\n * @param b\n * @param options\n */\nfunction merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var first = args.shift();\n    return args.reduce(function (target, source, index) {\n        if (!target || (target === source)) {\n            return cloneDeep(source);\n        }\n        else if ((0, lang_1.isArray)(source)) {\n            // If there is no target array, then make it one.\n            if (!(0, lang_1.isArray)(target)) {\n                args[index] = target = [];\n            }\n            return mergeArray(target, source);\n        }\n        else if ((0, lang_1.isPlainObject)(source)) {\n            return mergeObject(target, source);\n        }\n        else {\n            return cloneDeep(source);\n        }\n    }, first);\n}\nexports.merge = merge;\n/**\n * Performs a fast clone deep operation.\n *\n * @param obj\n */\nfunction fastCloneDeep(obj) {\n    try {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    catch (err) {\n        console.log(\"Clone Failed: \".concat(err.message));\n        return null;\n    }\n}\nexports.fastCloneDeep = fastCloneDeep;\n/**\n * Performs a shallow clone of an object.\n * @param src\n */\nfunction clone(src) {\n    if (Array.isArray(src)) { // for arrays\n        return __spreadArray([], src, true);\n    }\n    else {\n        return __assign({}, src);\n    }\n}\nexports.clone = clone;\n/**\n * Performs a recursive cloneDeep operation.\n * @param src\n * @returns\n */\nfunction cloneDeep(src) {\n    if (Array.isArray(src)) { // for arrays\n        return src.map(cloneDeep);\n    }\n    if (src === null || typeof src !== 'object') { // for primitives / functions / non-references/pointers\n        return src;\n    }\n    return Object.fromEntries(Object.entries(src).map(function (_a) {\n        var key = _a[0], val = _a[1];\n        return ([key, cloneDeep(val)]);\n    }));\n}\nexports.cloneDeep = cloneDeep;\n/**\n * Sets the defaults of an object.\n *\n * @param obj\n * @param defs\n */\nfunction defaults(obj, defs) {\n    (0, array_1.each)(defs, function (value, key) {\n        if (!obj.hasOwnProperty(key)) {\n            obj[key] = value;\n        }\n    });\n    return obj;\n}\nexports.defaults = defaults;\n/**\n * Pick an item in an object.\n * @param object\n * @param keys\n */\nfunction pick(object, keys) {\n    return keys.reduce(function (obj, key) {\n        if (object && object.hasOwnProperty(key)) {\n            obj[key] = object[key];\n        }\n        return obj;\n    }, {});\n}\nexports.pick = pick;\n;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/object.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/string.js":
/*!***************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/string.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.endsWith = exports.trim = void 0;\n// From https://youmightnotneed.com/lodash/#trim\nfunction trim(str, c) {\n    if (c === void 0) { c = '\\\\s'; }\n    return str.replace(new RegExp(\"^([\".concat(c, \"]*)(.*?)([\").concat(c, \"]*)$\")), '$2');\n}\nexports.trim = trim;\n// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nif (!String.prototype.endsWith) {\n    String.prototype.endsWith = function (search, this_len) {\n        if (this_len === undefined || this_len > this.length) {\n            this_len = this.length;\n        }\n        // @ts-ignore: Object is possibly 'undefined'\n        return this.substring(this_len - search.length, this_len) === search;\n    };\n}\n// From https://youmightnotneed.com/lodash/#endsWith\nfunction endsWith(str, c) {\n    return str.endsWith(c);\n}\nexports.endsWith = endsWith;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/string.js?");

/***/ }),

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/***/ (function(module) {

eval("/*! @license DOMPurify 3.0.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.3/LICENSE */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  const {\n    entries,\n    setPrototypeOf,\n    isFrozen,\n    getPrototypeOf,\n    getOwnPropertyDescriptor\n  } = Object;\n  let {\n    freeze,\n    seal,\n    create\n  } = Object; // eslint-disable-line import/no-mutable-exports\n\n  let {\n    apply,\n    construct\n  } = typeof Reflect !== 'undefined' && Reflect;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new Func(...args);\n    };\n  }\n\n  const arrayForEach = unapply(Array.prototype.forEach);\n  const arrayPop = unapply(Array.prototype.pop);\n  const arrayPush = unapply(Array.prototype.push);\n  const stringToLowerCase = unapply(String.prototype.toLowerCase);\n  const stringToString = unapply(String.prototype.toString);\n  const stringMatch = unapply(String.prototype.match);\n  const stringReplace = unapply(String.prototype.replace);\n  const stringIndexOf = unapply(String.prototype.indexOf);\n  const stringTrim = unapply(String.prototype.trim);\n  const regExpTest = unapply(RegExp.prototype.test);\n  const typeErrorCreate = unconstruct(TypeError);\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n  /* Add properties to a lookup table */\n\n  function addToSet(set, array, transformCaseFunc) {\n    var _transformCaseFunc;\n\n    transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    let l = array.length;\n\n    while (l--) {\n      let element = array[l];\n\n      if (typeof element === 'string') {\n        const lcElement = transformCaseFunc(element);\n\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n  /* Shallow clone an object */\n\n  function clone(object) {\n    const newObject = create(null);\n\n    for (const [property, value] of entries(object)) {\n      newObject[property] = value;\n    }\n\n    return newObject;\n  }\n  /* This method automatically checks if the prop is function\n   * or getter and behaves accordingly. */\n\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      const desc = getOwnPropertyDescriptor(object, prop);\n\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG\n\n  const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n\n  const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']); // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n\n  const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  const text = freeze(['#text']);\n\n  const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n  const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n\n  const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n  const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n  const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n\n  const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n\n  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n  const DOCTYPE_NAME = seal(/^html$/i);\n\n  var EXPRESSIONS = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    ERB_EXPR: ERB_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR,\n    DATA_ATTR: DATA_ATTR,\n    ARIA_ATTR: ARIA_ATTR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    DOCTYPE_NAME: DOCTYPE_NAME\n  });\n\n  const getGlobal = () => typeof window === 'undefined' ? null : window;\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported or creating the policy failed).\n   */\n\n\n  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    } // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n\n\n    let suffix = null;\n    const ATTR_NAME = 'data-tt-policy-suffix';\n\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n      suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n\n    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML(html) {\n          return html;\n        },\n\n        createScriptURL(scriptUrl) {\n          return scriptUrl;\n        }\n\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    const DOMPurify = root => createDOMPurify(root);\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n\n\n    DOMPurify.version = '3.0.3';\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n\n    const originalDocument = window.document;\n    const currentScript = originalDocument.currentScript;\n    let {\n      document\n    } = window;\n    const {\n      DocumentFragment,\n      HTMLTemplateElement,\n      Node,\n      Element,\n      NodeFilter,\n      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n      HTMLFormElement,\n      DOMParser,\n      trustedTypes\n    } = window;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    const getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n\n    if (typeof HTMLTemplateElement === 'function') {\n      const template = document.createElement('template');\n\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    let trustedTypesPolicy;\n    let emptyHTML = '';\n    const {\n      implementation,\n      createNodeIterator,\n      createDocumentFragment,\n      getElementsByTagName\n    } = document;\n    const {\n      importNode\n    } = originalDocument;\n    let hooks = {};\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n\n    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n    const {\n      MUSTACHE_EXPR,\n      ERB_EXPR,\n      TMPLIT_EXPR,\n      DATA_ATTR,\n      ARIA_ATTR,\n      IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE\n    } = EXPRESSIONS;\n    let {\n      IS_ALLOWED_URI: IS_ALLOWED_URI$1\n    } = EXPRESSIONS;\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n    /* Allowed attribute names */\n\n    let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n    /*\n     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n     */\n\n    let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n\n    let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n\n    let FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */\n\n    let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */\n\n    let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */\n\n    let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n     * Usually removed due to a mXSS issue in jQuery 3.0 */\n\n    let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n\n    let SAFE_FOR_TEMPLATES = false;\n    /* Decide if document with <html>... should be returned */\n\n    let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */\n\n    let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n\n    let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n\n    let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n\n    let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n\n    let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n     */\n\n    let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n     *\n     * HTML/DOM spec rules that enable DOM Clobbering:\n     *   - Named Access on Window (7.3.3)\n     *   - DOM Tree Accessors (3.1.5)\n     *   - Form Element Parent-Child Relations (4.10.3)\n     *   - Iframe srcdoc / Nested WindowProxies (4.8.5)\n     *   - HTMLCollection (4.2.10.2)\n     *\n     * Namespace isolation is implemented by prefixing `id` and `name` attributes\n     * with a constant string, i.e., `user-content-`\n     */\n\n    let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n    /* Keep element content when removing element? */\n\n    let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n\n    let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */\n\n    let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n\n    let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    /* Tags that are safe for data: URIs */\n\n    let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    /* Attributes safe for values like \"javascript:\" */\n\n    let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n\n    let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */\n\n    let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n    /* Parsing of strict XHTML documents */\n\n    let PARSER_MEDIA_TYPE;\n    const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    let transformCaseFunc;\n    /* Keep a reference to config to pass to hooks */\n\n    let CONFIG = null;\n    /* Ideally, do not touch anything below this line */\n\n    /* ______________________________________________ */\n\n    const formElement = document.createElement('form');\n\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n\n\n    const _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n      /* Shield configuration object from tampering */\n\n\n      if (!cfg || typeof cfg !== 'object') {\n        cfg = {};\n      }\n      /* Shield configuration object from prototype pollution */\n\n\n      cfg = clone(cfg);\n      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n      /* Set configuration parameters */\n\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent\n      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent\n      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n\n      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n\n      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n      /* Parse profile info */\n\n\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [...text]);\n        ALLOWED_ATTR = [];\n\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html$1);\n          addToSet(ALLOWED_ATTR, html);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg$1);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl$1);\n          addToSet(ALLOWED_ATTR, mathMl);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n      /* Merge configuration parameters */\n\n\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n      }\n      /* Add #text in case KEEP_CONTENT is set to true */\n\n\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n\n\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n\n\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      if (cfg.TRUSTED_TYPES_POLICY) {\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n        }\n\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n        } // Overwrite existing TrustedTypes policy.\n\n\n        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY; // Sign local variables required by `sanitize`.\n\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      } else {\n        // Uninitialized policy, attempt to initialize the internal dompurify policy.\n        if (trustedTypesPolicy === undefined) {\n          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n        } // If creating the internal policy succeeded sign internal variables.\n\n\n        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        }\n      } // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n\n\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    const HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n\n    const ALL_SVG_TAGS = addToSet({}, svg$1);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n\n    const _checkValidNamespace = function _checkValidNamespace(element) {\n      let parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      const tagName = stringToLowerCase(element.tagName);\n      const parentTagName = stringToLowerCase(parent.tagName);\n\n      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return false;\n      }\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        } // The only way to switch from MathML to SVG is via`\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n\n\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        } // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n\n\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        } // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n\n\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        } // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n\n\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        } // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n\n\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      } // For XHTML and XML documents that support custom namespaces\n\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return true;\n      } // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n      // Return false just in case.\n\n\n      return false;\n    };\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n\n\n    const _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        node.remove();\n      }\n    };\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n\n\n    const _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name); // We void attribute values for unremovable \"is\"\" attributes\n\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n\n\n    const _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      let doc;\n      let leadingWhitespace;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n      /* Use createHTMLDocument in case DOMParser is not available */\n\n\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n        } catch (_) {// Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      const body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n      /* Work on whole document or just its body */\n\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n\n\n    const _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n\n\n    const _isClobbered = function _isClobbered(elm) {\n      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n    };\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n\n\n    const _isNode = function _isNode(object) {\n      return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n\n\n    const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], hook => {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n\n\n    const _sanitizeElements = function _sanitizeElements(currentNode) {\n      let content;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeElements', currentNode, null);\n      /* Check if element is clobbered or can clobber */\n\n\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Now let's check the element's type and name */\n\n\n      const tagName = transformCaseFunc(currentNode.nodeName);\n      /* Execute a hook if present */\n\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n      /* Detect mXSS attempts abusing namespace confusion */\n\n\n      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Remove element if anything forbids its presence */\n\n\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Check if we have a custom element to handle */\n        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n        }\n        /* Keep content except for bad-listed elements */\n\n\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            const childCount = childNodes.length;\n\n            for (let i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Check whether element has a valid namespace */\n\n\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Make sure that older browsers don't get noscript mXSS */\n\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Sanitize element content to be template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR, ' ');\n        content = stringReplace(content, ERB_EXPR, ' ');\n        content = stringReplace(content, TMPLIT_EXPR, ' ');\n\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n\n\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n\n\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {\n          return false;\n        }\n        /* Check value is safe. First, is attr inert? If so, is safe */\n\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {\n        return false;\n      } else ;\n\n      return true;\n    };\n    /**\n     * _basicCustomElementCheck\n     * checks if at least one dash is included in tagName, and it's not the first char\n     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n     * @param {string} tagName name of the tag of the node to sanitize\n     */\n\n\n    const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n      return tagName.indexOf('-') > 0;\n    };\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n\n\n    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      let attr;\n      let value;\n      let lcName;\n      let l;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      const {\n        attributes\n      } = currentNode;\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      const hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n      /* Go backwards over all attributes; safely remove bad ones */\n\n      while (l--) {\n        attr = attributes[l];\n        const {\n          name,\n          namespaceURI\n        } = attr;\n        value = name === 'value' ? attr.value : stringTrim(attr.value);\n        lcName = transformCaseFunc(name);\n        /* Execute a hook if present */\n\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n        /* Remove attribute */\n\n\n        _removeAttribute(name, currentNode);\n        /* Did the hooks approve of the attribute? */\n\n\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n        /* Work around a security issue in jQuery 3.0 */\n\n\n        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n        /* Sanitize attribute content to be template-safe */\n\n\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR, ' ');\n          value = stringReplace(value, ERB_EXPR, ' ');\n          value = stringReplace(value, TMPLIT_EXPR, ' ');\n        }\n        /* Is `value` valid for this attribute? */\n\n\n        const lcTag = transformCaseFunc(currentNode.nodeName);\n\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n        /* Full DOM Clobbering protection via namespace isolation,\n         * Prefix id and name attributes with `user-content-`\n         */\n\n\n        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n          // Remove the attribute with this value\n          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value\n\n\n          value = SANITIZE_NAMED_PROPS_PREFIX + value;\n        }\n        /* Handle attributes that require Trusted Types */\n\n\n        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n          if (namespaceURI) ; else {\n            switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML':\n                {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n\n              case 'TrustedScriptURL':\n                {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n            }\n          }\n        }\n        /* Handle invalid data-* attribute set by try-catching it */\n\n\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n\n\n    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      let shadowNode;\n\n      const shadowIterator = _createIterator(fragment);\n      /* Execute a hook if present */\n\n\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n        /* Sanitize tags and elements */\n\n\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n        /* Deep shadow DOM detected */\n\n\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(shadowNode);\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n\n\n    DOMPurify.sanitize = function (dirty) {\n      let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let body;\n      let importedNode;\n      let currentNode;\n      let returnNode;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n\n      IS_EMPTY_INPUT = !dirty;\n\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n      /* Stringify, in case dirty is an object */\n\n\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString === 'function') {\n          dirty = dirty.toString();\n\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        } else {\n          throw typeErrorCreate('toString is not a function');\n        }\n      }\n      /* Return dirty HTML if DOMPurify cannot run */\n\n\n      if (!DOMPurify.isSupported) {\n        return dirty;\n      }\n      /* Assign config vars */\n\n\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n      /* Clean up removed elements */\n\n\n      DOMPurify.removed = [];\n      /* Check if dirty is correctly typed for IN_PLACE */\n\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) {\n        /* Do some early pre-sanitization to avoid unsafe root nodes */\n        if (dirty.nodeName) {\n          const tagName = transformCaseFunc(dirty.nodeName);\n\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n        /* Initialize the document to work on */\n\n\n        body = _initDocument(dirty);\n        /* Check we have a DOM node from the data */\n\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n      /* Remove first element node (ours) if FORCE_BODY is set */\n\n\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n      /* Get node iterator */\n\n\n      const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n      /* Now start iterating over the created document */\n\n\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n        /* Shadow DOM detected, sanitize it */\n\n\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(currentNode);\n      }\n      /* If we sanitized `dirty` in-place, return it. */\n\n\n      if (IN_PLACE) {\n        return dirty;\n      }\n      /* Return sanitized string or DOM */\n\n\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n      /* Serialize doctype if allowed */\n\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n      /* Sanitize final string template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n\n\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n\n      SET_CONFIG = true;\n    };\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n\n\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n\n\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      const lcTag = transformCaseFunc(tag);\n      const lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n\n\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     * @return {Function} removed(popped) hook\n     */\n\n\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        return arrayPop(hooks[entryPoint]);\n      }\n    };\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n\n\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n\n\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/dompurify/dist/purify.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./src/base/Components.ts":
/*!********************************!*\
  !*** ./src/base/Components.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.render = exports.Components = void 0;\n/**\n * Manages all of the components within the Form.io renderer.\n */\nclass Components {\n    /**\n     * Gets a specific component type.\n     *\n     * @param type\n     * @param from\n     * @returns\n     */\n    static component(type, from = 'components') {\n        if (Components[from][type]) {\n            return Components[from][type];\n        }\n        else {\n            return Components[from].component;\n        }\n    }\n    /**\n     * Create a new component.\n     *\n     * ```ts\n     * const htmlComp = Components.createComponent({\n     *    type: 'html',\n     *    tag: 'p',\n     *    content: 'This is a test.'\n     * })\n     * ```\n     *\n     * @param comp The component JSON you wish to create.\n     * @param options The options to pass to this component.\n     * @param data The data you wish to provide to this component.\n     */\n    static create(comp, options, data) {\n        return new (Components.component(comp.type))(comp, options, data);\n    }\n    /**\n     * Adds a base decorator type component.\n     *\n     * @param baseComponent\n     * @param type\n     */\n    static addDecorator(decorator, type) {\n        Components.decorators[type] = decorator;\n    }\n    /**\n     * Adds a new component to the renderer. Can either be a component class or a component JSON\n     * to be imported.\n     *\n     * @param component\n     */\n    static addComponent(component, type) {\n        if (!component) {\n            return;\n        }\n        if (typeof component !== 'function') {\n            return Components.importComponent(component);\n        }\n        Components.components[type] = component;\n        return component;\n    }\n    /**\n     * Imports a new component based on the JSON decorator of that component.\n     * @param component\n     */\n    static importComponent(props = {}) {\n        const Decorator = Components.component(props.extends, 'decorators');\n        let ExtendedComponent = class ExtendedComponent {\n        };\n        ExtendedComponent = __decorate([\n            Decorator(props)\n        ], ExtendedComponent);\n        Components.addComponent(ExtendedComponent, props.type);\n    }\n    /**\n     * Sets the components used within this renderer.\n     * @param components\n     */\n    static setComponents(components) {\n        Object.assign(Components.components, components);\n    }\n}\nexports.Components = Components;\n/**\n * An array of Components available to be rendered.\n */\nComponents.components = {};\nComponents.decorators = {};\n/**\n * Render a component attached to an html component.\n *\n * @param element\n * @param component\n * @param options\n * @param data\n */\nfunction render(element, component, options = {}, data = {}) {\n    return Components.create(component, options, data).attach(element);\n}\nexports.render = render;\n\n\n//# sourceURL=webpack://@formio/core/./src/base/Components.ts?");

/***/ }),

/***/ "./src/base/Template.ts":
/*!******************************!*\
  !*** ./src/base/Template.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Template = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\n/**\n * Manages all the available templates which can be rendered.\n */\nclass Template {\n    /**\n     * Adds a collection of template frameworks to the renderer.\n     * @param templates\n     */\n    static addTemplates(templates) {\n        var framework = Template.framework;\n        Template.templates = _.merge(Template.templates, templates);\n        Template.framework = framework;\n    }\n    /**\n     * Adds some templates to the existing template.\n     * @param name\n     * @param template\n     */\n    static addTemplate(name, template) {\n        Template.templates[name] = _.merge(Template.current, template);\n    }\n    /**\n     * Extend an existing template.\n     * @param name\n     * @param template\n     */\n    static extendTemplate(name, template) {\n        Template.templates[name] = _.merge(Template.templates[name], template);\n    }\n    /**\n     * Sets a template.\n     * @param name\n     * @param template\n     */\n    static setTemplate(name, template) {\n        Template.addTemplate(name, template);\n    }\n    /**\n     * Set the current template.\n     */\n    static set current(templates) {\n        const defaultTemplates = Template.current;\n        Template._current = _.merge(defaultTemplates, templates);\n    }\n    /**\n     * Get the current template.\n     */\n    static get current() {\n        return Template._current;\n    }\n    /**\n     * Sets the current framework.\n     */\n    static set framework(framework) {\n        if (Template.templates.hasOwnProperty(framework)) {\n            Template._framework = framework;\n            Template._current = Template.templates[framework];\n        }\n    }\n    /**\n     * Gets the current framework.\n     */\n    static get framework() {\n        return Template._framework;\n    }\n    /**\n     * Render a partial within the current template.\n     * @param name\n     * @param ctx\n     * @param mode\n     * @returns\n     */\n    static render(name, ctx, mode = 'html', defaultTemplate = null) {\n        if (typeof name === 'function') {\n            return name(ctx);\n        }\n        if (this.current[name] && this.current[name][mode]) {\n            return this.current[name][mode](ctx);\n        }\n        if (defaultTemplate) {\n            return defaultTemplate(ctx);\n        }\n        return 'Unknown template';\n    }\n}\nexports.Template = Template;\nTemplate.templates = [];\nTemplate._current = {};\nTemplate._framework = 'bootstrap';\n\n\n//# sourceURL=webpack://@formio/core/./src/base/Template.ts?");

/***/ }),

/***/ "./src/base/array/ArrayComponent.ts":
/*!******************************************!*\
  !*** ./src/base/array/ArrayComponent.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArrayComponent = void 0;\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/base/Components.ts\");\nconst model_1 = __webpack_require__(/*! @formio/model */ \"./src/model/index.ts\");\nconst NestedComponent_1 = __webpack_require__(/*! ../nested/NestedComponent */ \"./src/base/nested/NestedComponent.ts\");\n/**\n * An array data type component. This provides a nested component that creates \"rows\" of data\n * where each row creates new instances of the JSON components and sets the data context for\n * each row according to the row it is within.\n *\n * For example, if you have the following JSON schema.\n *\n * ```\n * {\n *   type: 'array',\n *   key: 'customers',\n *   components: [\n *     {\n *        type: 'datavalue',\n *        key: 'firstName'\n *     },\n *     {\n *        type: 'datavalue',\n *        key: 'lastName'\n *     }\n *   ]\n * }\n * ```\n *\n * You can now create multiple rows using the following data.\n *\n * ```\n * {\n *    customers: [\n *      {firstName: 'Joe', lastName: 'Smith'},\n *      {firstName: 'Sally', lastName: 'Thompson'},\n *      {firstName: 'Sue', lastName: 'Warner'}\n *    ]\n * }\n * ```\n */\nfunction ArrayComponent(props = {}) {\n    if (!props.type) {\n        props.type = 'array';\n    }\n    if (!props.model) {\n        props.model = model_1.NestedArrayModel;\n    }\n    return function (BaseClass) {\n        return class ExtendedArrayComponent extends (0, NestedComponent_1.NestedComponent)(props)(BaseClass) {\n        };\n    };\n}\nexports.ArrayComponent = ArrayComponent;\nComponents_1.Components.addDecorator(ArrayComponent, 'array');\nComponents_1.Components.addComponent(ArrayComponent()(), 'array');\n\n\n//# sourceURL=webpack://@formio/core/./src/base/array/ArrayComponent.ts?");

/***/ }),

/***/ "./src/base/component/Component.ts":
/*!*****************************************!*\
  !*** ./src/base/component/Component.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Component = void 0;\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/base/Components.ts\");\nconst Template_1 = __webpack_require__(/*! ../Template */ \"./src/base/Template.ts\");\nconst Evaluator_1 = __webpack_require__(/*! @formio/utils/Evaluator */ \"./src/utils/Evaluator.ts\");\nconst dom = __importStar(__webpack_require__(/*! @formio/utils/dom */ \"./src/utils/dom.ts\"));\nconst sanitize_1 = __webpack_require__(/*! @formio/utils/sanitize */ \"./src/utils/sanitize.ts\");\nconst model_1 = __webpack_require__(/*! @formio/model */ \"./src/model/index.ts\");\nconst object_1 = __webpack_require__(/*! @formio/lodash/lib/object */ \"./node_modules/@formio/lodash/lib/object.js\");\nfunction Component(props = {}) {\n    props = (0, object_1.merge)({\n        type: 'component',\n        template: false,\n        schema: {\n            persistent: true,\n            protected: false,\n        }\n    }, props);\n    props.schema.type = props.type;\n    const ModelClass = props.model || model_1.Model;\n    return function (BaseClass) {\n        return class ExtendedComponent extends ModelClass(props)(BaseClass) {\n            constructor() {\n                super(...arguments);\n                /**\n                 * Boolean to let us know if this component is attached to the DOM or not.\n                 */\n                this.attached = false;\n                /**\n                 * The DOM element references used for component logic.\n                 */\n                this.refs = {};\n                /**\n                 * The template to render for this component.\n                 */\n                this.template = props.template;\n                /**\n                 * An array of attached listeners.\n                 */\n                this.attachedListeners = [];\n            }\n            get defaultOptions() {\n                return {\n                    language: 'en',\n                    namespace: 'formio'\n                };\n            }\n            get defaultTemplate() {\n                return (ctx) => `<span>${ctx.t('Unknown Component')}</span>`;\n            }\n            /**\n             * Interpolate a template string.\n             * @param template - The template string to interpolate.\n             * @param context - The context variables to pass to the interpolation.\n             */\n            interpolate(template, context) {\n                return Evaluator_1.Evaluator.interpolate(template, context);\n            }\n            /**\n             * The rendering context.\n             * @param context - The existing contexts from parent classes.\n             */\n            renderContext(context = {}) {\n                if (super.renderContext) {\n                    return super.renderContext(context);\n                }\n                return context;\n            }\n            /**\n             * Performs an evaluation using the evaluation context of this component.\n             *\n             * @param func\n             * @param args\n             * @param ret\n             * @param tokenize\n             * @return {*}\n             */\n            evaluate(func, args = {}, ret = '', tokenize = false) {\n                return Evaluator_1.Evaluator.evaluate(func, this.evalContext(args), ret, tokenize);\n            }\n            /**\n             * Renders this component as an HTML string.\n             */\n            render(context = {}) {\n                if (super.render) {\n                    return super.render(context);\n                }\n                return this.renderTemplate((this.template || this.component.type), this.renderContext(context));\n            }\n            /**\n             * Returns the template references.\n             */\n            getRefs() {\n                if (super.getRefs) {\n                    return super.getRefs();\n                }\n                return {};\n            }\n            /**\n             * Loads the elemement references.\n             * @param element\n             */\n            loadRefs(element) {\n                const refs = this.getRefs();\n                for (const ref in refs) {\n                    if (refs[ref] === 'single') {\n                        this.refs[ref] = element.querySelector(`[ref=\"${ref}\"]`);\n                    }\n                    else {\n                        this.refs[ref] = element.querySelectorAll(`[ref=\"${ref}\"]`);\n                    }\n                }\n            }\n            /**\n             * Renders the component and then attaches this component to the HTMLElement.\n             * @param element\n             */\n            attach(element) {\n                const _super = Object.create(null, {\n                    attach: { get: () => super.attach }\n                });\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (this.element && !element) {\n                        element = this.element;\n                    }\n                    if (!element) {\n                        return this;\n                    }\n                    const parent = element.parentNode;\n                    if (!parent) {\n                        return this;\n                    }\n                    const index = Array.prototype.indexOf.call(parent.children, element);\n                    element.outerHTML = String(this.sanitize(this.render()));\n                    element = parent.children[index];\n                    this.element = element;\n                    this.loadRefs(this.element);\n                    if (_super.attach) {\n                        yield _super.attach.call(this, element);\n                    }\n                    this.attached = true;\n                    return this;\n                });\n            }\n            /**\n             * Redraw this component.\n             * @returns\n             */\n            redraw() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (this.element) {\n                        this.clear();\n                        return this.attach();\n                    }\n                });\n            }\n            /**\n             * Sanitize an html string.\n             *\n             * @param string\n             * @returns {*}\n             */\n            sanitize(dirty) {\n                return (0, sanitize_1.sanitize)(dirty, this.options);\n            }\n            /**\n             * Get all available translations.\n             */\n            get translations() {\n                if (this.options.language &&\n                    this.options.i18n &&\n                    this.options.i18n[this.options.language]) {\n                    return this.options.i18n[this.options.language];\n                }\n                return {};\n            }\n            /**\n             * Tranlation method to translate a string being rendered.\n             * @param str\n             */\n            t(str) {\n                if (this.translations[str]) {\n                    return this.translations[str];\n                }\n                return str;\n            }\n            /**\n             * The evaluation context for interpolations.\n             * @param extend\n             */\n            evalContext(extend = {}) {\n                return Object.assign({\n                    instance: this,\n                    component: this.component,\n                    options: this.options,\n                    row: this.data,\n                    data: this.root ? this.root.data : this.data,\n                    rowIndex: this.rowIndex,\n                    value: () => this.dataValue,\n                    t: (str) => this.t(str)\n                }, extend);\n            }\n            /**\n             * Render a template with provided context.\n             * @param name\n             * @param ctx\n             */\n            renderTemplate(name, ctx = {}) {\n                return Template_1.Template.render(name, this.evalContext(ctx), 'html', this.defaultTemplate);\n            }\n            /**\n             * Determines if the value of this component is redacted from the user as if it is coming from the server, but is protected.\n             *\n             * @return {boolean|*}\n             */\n            isValueRedacted() {\n                return (this.component.protected ||\n                    !this.component.persistent ||\n                    (this.component.persistent === 'client-only'));\n            }\n            /**\n             * Sets the data value and updates the view representation.\n             * @param value\n             */\n            setValue(value) {\n                let changed = false;\n                if (super.setValue) {\n                    changed = super.setValue(value);\n                }\n                return this.updateValue(value) || changed;\n            }\n            /**\n             * Returns the main HTML Element for this component.\n             */\n            getElement() {\n                return this.element;\n            }\n            /**\n             * Remove all event handlers.\n             */\n            detach() {\n                this.refs = {};\n                this.attached = false;\n                this.removeAttachedListeners();\n                if (super.detach) {\n                    super.detach();\n                }\n            }\n            /**\n             * Clear an element.\n             */\n            clear() {\n                this.detach();\n                dom.empty(this.getElement());\n                if (super.clear) {\n                    super.clear();\n                }\n            }\n            /**\n             * Appends an element to this component.\n             * @param element\n             */\n            append(element) {\n                dom.appendTo(element, this.element);\n            }\n            /**\n             * Prepends an element to this component.\n             * @param element\n             */\n            prepend(element) {\n                dom.prependTo(element, this.element);\n            }\n            /**\n             * Removes an element from this component.\n             * @param element\n             */\n            removeChild(element) {\n                dom.removeChildFrom(element, this.element);\n            }\n            /**\n             * Wrapper method to add an event listener to an HTML element.\n             *\n             * @param obj\n             *   The DOM element to add the event to.\n             * @param type\n             *   The event name to add.\n             * @param func\n             *   The callback function to be executed when the listener is triggered.\n             * @param persistent\n             *   If this listener should persist beyond \"destroy\" commands.\n             */\n            addEventListener(obj, type, func) {\n                if (!obj) {\n                    return;\n                }\n                if ('addEventListener' in obj) {\n                    obj.addEventListener(type, func, false);\n                }\n                else if ('attachEvent' in obj) {\n                    obj.attachEvent(`on${type}`, func);\n                }\n                this.attachedListeners.push({ obj, type, func });\n                return this;\n            }\n            /**\n             * Remove all the attached listeners.\n             */\n            removeAttachedListeners() {\n                this.attachedListeners.forEach((item) => this.removeEventListener(item.obj, item.type, item.func));\n                this.attachedListeners = [];\n            }\n            /**\n             * Remove an event listener from the object.\n             *\n             * @param obj\n             * @param type\n             */\n            removeEventListener(obj, type, func) {\n                if (obj) {\n                    obj.removeEventListener(type, func);\n                }\n                return this;\n            }\n        };\n    };\n}\nexports.Component = Component;\n// Add the default component.\nComponents_1.Components.addDecorator(Component, 'component');\nComponents_1.Components.addComponent(Component()(), 'component');\n\n\n//# sourceURL=webpack://@formio/core/./src/base/component/Component.ts?");

/***/ }),

/***/ "./src/base/data/DataComponent.ts":
/*!****************************************!*\
  !*** ./src/base/data/DataComponent.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataComponent = void 0;\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/base/Components.ts\");\nconst model_1 = __webpack_require__(/*! @formio/model */ \"./src/model/index.ts\");\nconst NestedComponent_1 = __webpack_require__(/*! ../nested/NestedComponent */ \"./src/base/nested/NestedComponent.ts\");\n/**\n * A DataComponent is one that establishes a new data context for all of its\n * children at the specified \"key\" of this comopnent. For example, if this data\n * component has a key of \"employee\", and then some components within the data\n * component of \"firstName\" and \"lastName\", the data structure provided by this\n * component would resemble the following.\n *\n * {\n *   \"employee\": {\n *      \"firstName\": \"Bob\",\n *      \"lastName\": \"Smith\"\n *   }\n * }\n */\nfunction DataComponent(props = {}) {\n    if (!props.type) {\n        props.type = 'data';\n    }\n    if (!props.model) {\n        props.model = model_1.NestedDataModel;\n    }\n    return function (BaseClass) {\n        return class ExtendedDataComponent extends (0, NestedComponent_1.NestedComponent)(props)(BaseClass) {\n        };\n    };\n}\nexports.DataComponent = DataComponent;\nComponents_1.Components.addDecorator(DataComponent, 'data');\nComponents_1.Components.addComponent(DataComponent()(), 'data');\n\n\n//# sourceURL=webpack://@formio/core/./src/base/data/DataComponent.ts?");

/***/ }),

/***/ "./src/base/index.ts":
/*!***************************!*\
  !*** ./src/base/index.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Template = exports.ArrayComponent = exports.DataComponent = exports.NestedComponent = exports.Component = exports.render = exports.Components = void 0;\nvar Components_1 = __webpack_require__(/*! ./Components */ \"./src/base/Components.ts\");\nObject.defineProperty(exports, \"Components\", ({ enumerable: true, get: function () { return Components_1.Components; } }));\nObject.defineProperty(exports, \"render\", ({ enumerable: true, get: function () { return Components_1.render; } }));\nvar Component_1 = __webpack_require__(/*! ./component/Component */ \"./src/base/component/Component.ts\");\nObject.defineProperty(exports, \"Component\", ({ enumerable: true, get: function () { return Component_1.Component; } }));\nvar NestedComponent_1 = __webpack_require__(/*! ./nested/NestedComponent */ \"./src/base/nested/NestedComponent.ts\");\nObject.defineProperty(exports, \"NestedComponent\", ({ enumerable: true, get: function () { return NestedComponent_1.NestedComponent; } }));\nvar DataComponent_1 = __webpack_require__(/*! ./data/DataComponent */ \"./src/base/data/DataComponent.ts\");\nObject.defineProperty(exports, \"DataComponent\", ({ enumerable: true, get: function () { return DataComponent_1.DataComponent; } }));\nvar ArrayComponent_1 = __webpack_require__(/*! ./array/ArrayComponent */ \"./src/base/array/ArrayComponent.ts\");\nObject.defineProperty(exports, \"ArrayComponent\", ({ enumerable: true, get: function () { return ArrayComponent_1.ArrayComponent; } }));\nvar Template_1 = __webpack_require__(/*! ./Template */ \"./src/base/Template.ts\");\nObject.defineProperty(exports, \"Template\", ({ enumerable: true, get: function () { return Template_1.Template; } }));\n__exportStar(__webpack_require__(/*! @formio/model */ \"./src/model/index.ts\"), exports);\n\n\n//# sourceURL=webpack://@formio/core/./src/base/index.ts?");

/***/ }),

/***/ "./src/base/nested/NestedComponent.ts":
/*!********************************************!*\
  !*** ./src/base/nested/NestedComponent.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NestedComponent = void 0;\nconst Components_1 = __webpack_require__(/*! ../Components */ \"./src/base/Components.ts\");\nconst Component_1 = __webpack_require__(/*! ../component/Component */ \"./src/base/component/Component.ts\");\nconst model_1 = __webpack_require__(/*! @formio/model */ \"./src/model/index.ts\");\nfunction NestedComponent(props = {}) {\n    if (!props.type) {\n        props.type = 'nested';\n    }\n    if (!props.model) {\n        props.model = model_1.NestedModel;\n    }\n    if (!props.factory) {\n        props.factory = Components_1.Components;\n    }\n    return function (BaseClass) {\n        return class ExtendedNestedComponent extends (0, Component_1.Component)(props)(BaseClass) {\n            get defaultTemplate() {\n                return (ctx) => `<div ref=\"nested\">${ctx.instance.renderComponents()}</div>`;\n            }\n            /**\n             * Attach a html element to this nestd component.\n             * @param element\n             */\n            attach(element) {\n                const _super = Object.create(null, {\n                    attach: { get: () => super.attach }\n                });\n                return __awaiter(this, void 0, void 0, function* () {\n                    yield _super.attach.call(this, element);\n                    if (this.element) {\n                        const promises = [];\n                        const children = this.element.querySelectorAll(`[data-within=\"${this.id}\"]`);\n                        Array.prototype.slice.call(children).forEach((child, index) => {\n                            promises.push(this.components[index].attach(child));\n                        });\n                        yield Promise.all(promises);\n                    }\n                    return this;\n                });\n            }\n            /**\n             * Detach components.\n             */\n            detach() {\n                super.detach();\n                this.eachComponent((comp) => comp.detach());\n            }\n            renderComponents() {\n                return this.components.reduce((tpl, comp) => {\n                    return tpl + comp.render().replace(/(<[^\\>]+)/, `$1 data-within=\"${this.id}\"`);\n                }, '');\n            }\n        };\n    };\n}\nexports.NestedComponent = NestedComponent;\nComponents_1.Components.addDecorator(NestedComponent, 'nested');\nComponents_1.Components.addComponent(NestedComponent()(), 'nested');\n\n\n//# sourceURL=webpack://@formio/core/./src/base/nested/NestedComponent.ts?");

/***/ }),

/***/ "./src/model/EventEmitter.ts":
/*!***********************************!*\
  !*** ./src/model/EventEmitter.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventEmitterBase = exports.EventEmitter = void 0;\nconst eventemitter3_1 = __importDefault(__webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\"));\nexports.EventEmitterBase = eventemitter3_1.default;\nfunction EventEmitter(BaseClass) {\n    if (!BaseClass) {\n        BaseClass = class _BaseClass {\n        };\n    }\n    return class EventEmitter extends BaseClass {\n        constructor() {\n            super(...arguments);\n            /**\n             * The parent entity.\n             */\n            this.parent = null;\n            /**\n             * The events to fire for this model.\n             */\n            this.events = new eventemitter3_1.default();\n        }\n        /**\n         * Bubble an event up to the parent.\n         *\n         * @param event\n         * @param args\n         * @returns\n         */\n        bubble(event, ...args) {\n            if (this.parent) {\n                return this.parent.bubble(event, ...args);\n            }\n            return this.emit(event, ...args);\n        }\n        /**\n         * Emit an event on this component.\n         * @param event\n         * @param args\n         * @returns\n         */\n        emit(event, ...args) {\n            return this.events.emit(event, ...args);\n        }\n        /**\n         * Register an event subscriber.\n         * @param event\n         * @param fn\n         * @param args\n         * @returns\n         */\n        on(event, fn, ...args) {\n            return this.events.on(event, fn, ...args);\n        }\n        /**\n         * Register an event subscriber that will only be called once.\n         * @param event\n         * @param fn\n         * @param args\n         * @returns\n         */\n        once(event, fn, ...args) {\n            return this.events.once(event, fn, ...args);\n        }\n        /**\n         * Turn off the event registrations.\n         * @param event\n         * @param args\n         * @returns\n         */\n        off(event, ...args) {\n            return this.events.off(event, ...args);\n        }\n    };\n}\nexports.EventEmitter = EventEmitter;\n\n\n//# sourceURL=webpack://@formio/core/./src/model/EventEmitter.ts?");

/***/ }),

/***/ "./src/model/Model.ts":
/*!****************************!*\
  !*** ./src/model/Model.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Model = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\nconst EventEmitter_1 = __webpack_require__(/*! ./EventEmitter */ \"./src/model/EventEmitter.ts\");\nfunction Model(props = {}) {\n    if (!props.schema) {\n        props.schema = {};\n    }\n    if (!props.schema.key) {\n        props.schema.key = '';\n    }\n    return function (BaseClass) {\n        return class BaseModel extends (0, EventEmitter_1.EventEmitter)(BaseClass) {\n            /**\n             * The validator for this component.\n             * @returns\n             */\n            /**\n             * The default JSON schema\n             * @param extend\n             */\n            static schema() {\n                return props.schema;\n            }\n            /**\n             * @constructor\n             * @param component\n             * @param options\n             * @param data\n             */\n            constructor(component = {}, options = {}, data = {}) {\n                super(component, options, data);\n                this.component = component;\n                this.options = options;\n                this.data = data;\n                /**\n                 * The root entity.\n                 */\n                this.root = null;\n                /**\n                 * The component validator instance.\n                 * @returns\n                 */\n                this.validator = null;\n                this.id = `e${Math.random().toString(36).substring(7)}`;\n                this.component = _.merge({}, this.defaultSchema, this.component);\n                this.options = Object.assign(Object.assign({}, this.defaultOptions), this.options);\n                if (!this.options.noInit) {\n                    this.init();\n                }\n            }\n            get defaultOptions() {\n                return {};\n            }\n            get defaultSchema() {\n                return BaseModel.schema();\n            }\n            /**\n             * Initializes the entity.\n             */\n            init() {\n                this.hook('init');\n                if (this.options.validator) {\n                    this.validator = this.options.validator.fromComponent(this);\n                }\n            }\n            /**\n             * Check the validity of this specific component.\n             *\n             * @returns\n             */\n            checkComponentValidity() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    return this.validator ? this.validator.check() : true;\n                });\n            }\n            /**\n             * Checks the validity of this component and all child components.\n             * @returns\n             */\n            checkValidity() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    return this.checkComponentValidity();\n                });\n            }\n            /**\n             * Return the errors from validation for this component.\n             */\n            get errors() {\n                return this.validator.errors;\n            }\n            /**\n             * The empty value for this component.\n             *\n             * @return {null}\n             */\n            get emptyValue() {\n                return null;\n            }\n            /**\n             * Checks to see if this components value is empty.\n             *\n             * @param value\n             * @returns\n             */\n            isEmpty(value = this.dataValue) {\n                const isEmptyArray = (_.isArray(value) && value.length === 1) ? _.isEqual(value[0], this.emptyValue) : false;\n                return value == null || value.length === 0 || _.isEqual(value, this.emptyValue) || isEmptyArray;\n            }\n            /**\n             * Returns the data value for this component.\n             */\n            get dataValue() {\n                return _.get(this.data, this.component.key);\n            }\n            /**\n             * Sets the datavalue for this component.\n             */\n            set dataValue(value) {\n                if (this.component.key) {\n                    _.set(this.data, this.component.key, value);\n                }\n            }\n            /**\n             * Determine if this component has changed values.\n             *\n             * @param value - The value to compare against the current value.\n             */\n            hasChanged(value) {\n                return String(value) !== String(this.dataValue);\n            }\n            /**\n             * Updates the data model value\n             * @param value The value to update within this component.\n             * @return boolean true if the value has changed.\n             */\n            updateValue(value) {\n                const changed = this.hasChanged(value);\n                this.dataValue = value;\n                if (changed) {\n                    // Bubble a change event.\n                    this.bubble('change', value);\n                }\n                return changed;\n            }\n            /**\n             * Get the model value.\n             * @returns\n             */\n            getValue() {\n                return this.dataValue;\n            }\n            /**\n             * Allow for options to hook into the functionality of this entity.\n             * @return {*}\n             */\n            hook(name, ...args) {\n                if (this.options &&\n                    this.options.hooks &&\n                    this.options.hooks[name]) {\n                    return this.options.hooks[name].apply(this, args);\n                }\n                else {\n                    // If this is an async hook instead of a sync.\n                    const fn = (typeof args[args.length - 1] === 'function') ? args[args.length - 1] : null;\n                    if (fn) {\n                        return fn(null, args[1]);\n                    }\n                    else {\n                        return args[1];\n                    }\n                }\n            }\n        };\n    };\n}\nexports.Model = Model;\n\n\n//# sourceURL=webpack://@formio/core/./src/model/Model.ts?");

/***/ }),

/***/ "./src/model/NestedArrayModel.ts":
/*!***************************************!*\
  !*** ./src/model/NestedArrayModel.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NestedArrayModel = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\nconst NestedDataModel_1 = __webpack_require__(/*! ./NestedDataModel */ \"./src/model/NestedDataModel.ts\");\nfunction NestedArrayModel(props = {}) {\n    return function (BaseClass) {\n        return class BaseNestedArrayModel extends (0, NestedDataModel_1.NestedDataModel)(props)(BaseClass) {\n            get defaultValue() {\n                return [];\n            }\n            /**\n             * Returns a row of componments at the provided index.\n             * @param index The index of the row to return\n             */\n            row(index) {\n                return (index < this.rows.length) ? this.rows[index] : [];\n            }\n            /**\n             * Removes a row and detatches all components within that row.\n             *\n             * @param index The index of the row to remove.\n             */\n            removeRow(index) {\n                this.row(index).forEach((comp) => this.removeComponent(comp));\n                this.dataValue.splice(index, 1);\n                this.rows.splice(index, 1);\n            }\n            /**\n             * Adds a new row of components.\n             *\n             * @param data The data context to pass to this row of components.\n             */\n            addRow(data = {}, index = 0) {\n                const rowData = data;\n                this.dataValue[index] = rowData;\n                this.createRowComponents(rowData, index);\n            }\n            /**\n             * Sets the data for a specific row of components.\n             * @param rowData The data to set\n             * @param index The index of the rows to set the data within.\n             */\n            setRowData(rowData, index) {\n                var _a;\n                this.dataValue[index] = rowData;\n                (_a = this.row(index)) === null || _a === void 0 ? void 0 : _a.forEach((comp) => (comp.data = rowData));\n            }\n            /**\n             * Determines if the data within a row has changed.\n             *\n             * @param rowData\n             * @param index\n             */\n            rowChanged(rowData, index) {\n                var _a;\n                let changed = false;\n                (_a = this.row(index)) === null || _a === void 0 ? void 0 : _a.forEach((comp) => {\n                    const hasChanged = comp.hasChanged(_.get(rowData, comp.component.key));\n                    changed = hasChanged || changed;\n                    if (hasChanged) {\n                        comp.bubble('change', comp);\n                    }\n                });\n                return changed;\n            }\n            /**\n             * Creates all components for each row.\n             * @param data\n             * @returns\n             */\n            createComponents(data) {\n                this.rows = [];\n                let added = [];\n                this.eachRowValue(data, (row, index) => {\n                    added = added.concat(this.createRowComponents(row, index));\n                });\n                return added;\n            }\n            /**\n             * Creates a new row of components.\n             *\n             * @param data The data context to pass along to this row of components.\n             */\n            createRowComponents(data, index = 0) {\n                const comps = super.createComponents(data, (comp) => {\n                    comp.rowIndex = index;\n                });\n                this.rows[index] = comps;\n                return comps;\n            }\n            getIndexes(value) {\n                if (super.getIndexes) {\n                    return super.getIndexes(value);\n                }\n                return {\n                    min: 0,\n                    max: (value.length - 1)\n                };\n            }\n            eachRowValue(value, fn) {\n                if (!value || !value.length) {\n                    return;\n                }\n                const indexes = this.getIndexes(value);\n                for (let i = indexes.min; i <= indexes.max; i++) {\n                    fn(value[i], i);\n                }\n            }\n            /**\n             * The empty value for this component.\n             *\n             * @return {array}\n             */\n            get emptyValue() {\n                return [];\n            }\n            /**\n             * Returns the dataValue for this component.\n             */\n            get dataValue() {\n                return _.get(this.data, this.component.key);\n            }\n            /**\n             * Set the datavalue of an array component.\n             *\n             * @param value The value to set this component to.\n             */\n            set dataValue(value) {\n                // Only set the value if it is an array.\n                if (Array.isArray(value)) {\n                    // Get the current data value.\n                    const dataValue = this.dataValue;\n                    this.eachRowValue(value, (row, index) => {\n                        if (index >= dataValue.length) {\n                            this.addRow(row, index);\n                        }\n                        this.setRowData(row, index);\n                    });\n                    // Remove superfluous rows.\n                    if (dataValue.length > value.length) {\n                        for (let i = value.length; i < dataValue.length; i++) {\n                            this.removeRow(i);\n                        }\n                    }\n                }\n            }\n            /**\n             * Determine if this array component has changed.\n             *\n             * @param value\n             */\n            hasChanged(value) {\n                const dataValue = this.dataValue;\n                // If the length changes, then this compnent has changed.\n                if (value.length !== dataValue.length) {\n                    this.emit('changed', this);\n                    return true;\n                }\n                let changed = false;\n                this.eachRowValue(value, (rowData, index) => {\n                    changed = this.rowChanged(rowData, index) || changed;\n                });\n                return changed;\n            }\n            /**\n             * Sets the value of an array component.\n             *\n             * @param value\n             */\n            setValue(value) {\n                var changed = false;\n                this.eachComponentValue(value, (comp, val) => {\n                    changed = comp.setValue(val) || changed;\n                });\n                return changed;\n            }\n        };\n    };\n}\nexports.NestedArrayModel = NestedArrayModel;\n;\n\n\n//# sourceURL=webpack://@formio/core/./src/model/NestedArrayModel.ts?");

/***/ }),

/***/ "./src/model/NestedDataModel.ts":
/*!**************************************!*\
  !*** ./src/model/NestedDataModel.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NestedDataModel = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\nconst NestedModel_1 = __webpack_require__(/*! ./NestedModel */ \"./src/model/NestedModel.ts\");\nfunction NestedDataModel(props = {}) {\n    return function (BaseClass) {\n        return class BaseNestedDataModel extends (0, NestedModel_1.NestedModel)(props)(BaseClass) {\n            get emptyValue() {\n                return {};\n            }\n            get defaultValue() {\n                return {};\n            }\n            /**\n             * Get the component data.\n             */\n            componentData() {\n                const compData = _.get(this.data, this.component.key, this.defaultValue);\n                if (!Object.keys(compData).length) {\n                    _.set(this.data, this.component.key, compData);\n                }\n                return compData;\n            }\n            get dataValue() {\n                return _.get(this.data, this.component.key);\n            }\n            set dataValue(value) {\n                this.eachComponentValue(value, (comp, val) => (comp.dataValue = val));\n            }\n        };\n    };\n}\nexports.NestedDataModel = NestedDataModel;\n;\n\n\n//# sourceURL=webpack://@formio/core/./src/model/NestedDataModel.ts?");

/***/ }),

/***/ "./src/model/NestedModel.ts":
/*!**********************************!*\
  !*** ./src/model/NestedModel.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NestedModel = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\nconst Model_1 = __webpack_require__(/*! ./Model */ \"./src/model/Model.ts\");\nfunction NestedModel(props = {}) {\n    if (!props.schema) {\n        props.schema = {};\n    }\n    if (!props.schema.components) {\n        props.schema.components = [];\n    }\n    return function (BaseClass) {\n        return class BaseNestedModel extends (0, Model_1.Model)(props)(BaseClass) {\n            /**\n             * Initialize the nested entity by creating the children.\n             */\n            init() {\n                super.init();\n                this.components = [];\n                this.createComponents(this.componentData());\n            }\n            /**\n             * Get the component data.\n             * @returns\n             */\n            componentData() {\n                return this.data;\n            }\n            /**\n             * Creates a new component entity.\n             * @param component\n             * @param options\n             * @param data\n             * @returns\n             */\n            createComponent(component, options, data) {\n                if (!props.factory) {\n                    console.log('Cannot create components. No \"factory\" provided.');\n                    return null;\n                }\n                const comp = props.factory.create(component, Object.assign({ noInit: true }, options), data);\n                comp.parent = this;\n                comp.root = this.root || this;\n                comp.init();\n                return comp;\n            }\n            /**\n             * Creates the components.\n             * @param data\n             * @returns\n             */\n            createComponents(data, eachComp) {\n                const added = [];\n                (this.component.components || []).forEach((comp) => {\n                    const newComp = this.createComponent(comp, this.options, data);\n                    if (newComp) {\n                        this.components.push(newComp);\n                        added.push(newComp);\n                        if (eachComp) {\n                            eachComp(newComp);\n                        }\n                    }\n                });\n                return added;\n            }\n            /**\n             * Removes a child comopnent.\n             * @param component\n             */\n            removeComponent(component) {\n                (this.components || []).forEach((comp, index) => {\n                    if (comp === component) {\n                        if (comp.detach) {\n                            comp.detach();\n                        }\n                        this.components.splice(index, 1);\n                    }\n                });\n            }\n            /**\n             * Checks for the validity of this component and all components within this component.\n             * @returns\n             */\n            checkValidity() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    return this.components.reduce((valid, comp) => {\n                        return valid && comp.checkValidity();\n                    }, this.checkComponentValidity());\n                });\n            }\n            /**\n             * Get the default value for this nested entity.\n             */\n            get defaultValue() {\n                return {};\n            }\n            /**\n             * The empty value for this component.\n             *\n             * @return {null}\n             */\n            get emptyValue() {\n                return {};\n            }\n            /**\n             * Get the datavalue of this component.\n             */\n            get dataValue() {\n                return this.data;\n            }\n            /**\n             * Perform an iteration over each component within this container component.\n             *\n             * @param {function} fn - Called for each component\n             */\n            eachComponent(fn) {\n                _.each(this.components, (component, index) => {\n                    if (fn(component, index) === false) {\n                        return false;\n                    }\n                });\n            }\n            /**\n             * Iterate through each component value.\n             *\n             * @param value The context data value.\n             * @param fn Callback to be called with the component and the value for that component.\n             */\n            eachComponentValue(value, fn) {\n                if (Object.keys(value).length) {\n                    this.eachComponent((comp) => {\n                        fn(comp, _.get(value, comp.component.key));\n                    });\n                }\n            }\n            /**\n             * Set the data value for this nested entity.\n             */\n            set dataValue(value) {\n                this.eachComponentValue(value, (comp, val) => (comp.dataValue = val));\n            }\n            /**\n             * Sets the value for a data component.\n             *\n             * @param value\n             */\n            setValue(value) {\n                var changed = false;\n                this.eachComponentValue(value, (comp, val) => {\n                    changed = comp.setValue(val) || changed;\n                });\n                return changed;\n            }\n        };\n    };\n}\nexports.NestedModel = NestedModel;\n;\n\n\n//# sourceURL=webpack://@formio/core/./src/model/NestedModel.ts?");

/***/ }),

/***/ "./src/model/index.ts":
/*!****************************!*\
  !*** ./src/model/index.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NestedArrayModel = exports.NestedDataModel = exports.NestedModel = exports.Model = exports.EventEmitter = void 0;\nvar EventEmitter_1 = __webpack_require__(/*! ./EventEmitter */ \"./src/model/EventEmitter.ts\");\nObject.defineProperty(exports, \"EventEmitter\", ({ enumerable: true, get: function () { return EventEmitter_1.EventEmitter; } }));\nvar Model_1 = __webpack_require__(/*! ./Model */ \"./src/model/Model.ts\");\nObject.defineProperty(exports, \"Model\", ({ enumerable: true, get: function () { return Model_1.Model; } }));\nvar NestedModel_1 = __webpack_require__(/*! ./NestedModel */ \"./src/model/NestedModel.ts\");\nObject.defineProperty(exports, \"NestedModel\", ({ enumerable: true, get: function () { return NestedModel_1.NestedModel; } }));\nvar NestedDataModel_1 = __webpack_require__(/*! ./NestedDataModel */ \"./src/model/NestedDataModel.ts\");\nObject.defineProperty(exports, \"NestedDataModel\", ({ enumerable: true, get: function () { return NestedDataModel_1.NestedDataModel; } }));\nvar NestedArrayModel_1 = __webpack_require__(/*! ./NestedArrayModel */ \"./src/model/NestedArrayModel.ts\");\nObject.defineProperty(exports, \"NestedArrayModel\", ({ enumerable: true, get: function () { return NestedArrayModel_1.NestedArrayModel; } }));\n\n\n//# sourceURL=webpack://@formio/core/./src/model/index.ts?");

/***/ }),

/***/ "./src/utils/Evaluator.ts":
/*!********************************!*\
  !*** ./src/utils/Evaluator.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Evaluator = exports.BaseEvaluator = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\n// BaseEvaluator is for extending.\nclass BaseEvaluator {\n    static evaluator(func, ...params) {\n        if (Evaluator.noeval) {\n            console.warn('No evaluations allowed for this renderer.');\n            return _.noop;\n        }\n        if (typeof func === 'function') {\n            return func;\n        }\n        if (typeof params[0] === 'object') {\n            params = _.keys(params[0]);\n        }\n        return new Function(...params, func);\n    }\n    ;\n    static interpolateString(rawTemplate, data, options = {}) {\n        return rawTemplate.replace(/({{\\s*(.*?)\\s*}})/g, (match, $1, $2) => {\n            // If this is a function call and we allow evals.\n            if ($2.indexOf('(') !== -1) {\n                return $2.replace(/([^\\(]+)\\(([^\\)]+)\\s*\\);?/, (evalMatch, funcName, args) => {\n                    funcName = _.trim(funcName);\n                    const func = _.get(data, funcName);\n                    if (func) {\n                        if (args) {\n                            args = args.split(',').map((arg) => {\n                                arg = _.trim(arg);\n                                if ((arg.indexOf('\"') === 0) || (arg.indexOf(\"'\") === 0)) {\n                                    return arg.substring(1, arg.length - 1);\n                                }\n                                return _.get(data, arg);\n                            });\n                        }\n                        return Evaluator.evaluate(func, args, '', false, data, options);\n                    }\n                    return '';\n                });\n            }\n            else {\n                let dataPath = $2;\n                if ($2.indexOf('?') !== -1) {\n                    dataPath = $2.replace(/\\?\\./g, '.');\n                }\n                // Allow for conditional values.\n                const parts = dataPath.split('||').map((item) => item.trim());\n                let value = '';\n                let path = '';\n                for (let i = 0; i < parts.length; i++) {\n                    path = parts[i];\n                    value = _.get(data, path);\n                    if (value) {\n                        break;\n                    }\n                }\n                if (options.data) {\n                    _.set(options.data, path, value);\n                }\n                return value;\n            }\n        });\n    }\n    static interpolate(rawTemplate, data, options = {}) {\n        if (typeof rawTemplate === 'function') {\n            try {\n                return rawTemplate(data);\n            }\n            catch (err) {\n                console.warn('Error interpolating template', err, data);\n                return err.message;\n            }\n        }\n        return Evaluator.interpolateString(String(rawTemplate), data, options);\n    }\n    ;\n    /**\n     * Evaluate a method.\n     *\n     * @param func\n     * @param args\n     * @return {*}\n     */\n    static evaluate(func, args = {}, ret = '', interpolate = false, context = {}, options = {}) {\n        let returnVal = null;\n        options = _.isObject(options) ? options : { noeval: options };\n        const component = args.component ? args.component : { key: 'unknown' };\n        if (!args.form && args.instance) {\n            args.form = _.get(args.instance, 'root._form', {});\n        }\n        const componentKey = component.key;\n        if (typeof func === 'string') {\n            if (ret) {\n                func += `;return ${ret}`;\n            }\n            if (interpolate) {\n                func = BaseEvaluator.interpolate(func, args, options);\n            }\n            try {\n                if (Evaluator.noeval || options.noeval) {\n                    func = _.noop;\n                }\n                else {\n                    func = Evaluator.evaluator(func, args, context);\n                }\n                args = _.values(args);\n            }\n            catch (err) {\n                console.warn(`An error occured within the custom function for ${componentKey}`, err);\n                returnVal = null;\n                func = false;\n            }\n        }\n        if (typeof func === 'function') {\n            try {\n                returnVal = Evaluator.execute(func, args, context, options);\n            }\n            catch (err) {\n                returnVal = null;\n                console.warn(`An error occured within custom function for ${componentKey}`, err);\n            }\n        }\n        else if (func) {\n            console.warn(`Unknown function type for ${componentKey}`);\n        }\n        return returnVal;\n    }\n    /**\n     * Execute a function.\n     *\n     * @param func\n     * @param args\n     * @returns\n     */\n    static execute(func, args, context = {}, options = {}) {\n        options = _.isObject(options) ? options : { noeval: options };\n        if (Evaluator.noeval || options.noeval) {\n            console.warn('No evaluations allowed for this renderer.');\n            return;\n        }\n        return Array.isArray(args) ? func.apply(context, args) : func.call(context, args);\n    }\n    ;\n}\nexports.BaseEvaluator = BaseEvaluator;\nBaseEvaluator.templateSettings = {\n    interpolate: /{{([\\s\\S]+?)}}/g,\n    evaluate: /\\{%([\\s\\S]+?)%\\}/g,\n    escape: /\\{\\{\\{([\\s\\S]+?)\\}\\}\\}/g\n};\nBaseEvaluator.noeval = false;\n// The extendable evaluator\nclass Evaluator extends BaseEvaluator {\n    /**\n     * Allow external modules the ability to extend the Evaluator.\n     * @param evaluator\n     */\n    static registerEvaluator(evaluator) {\n        Object.keys(evaluator).forEach((key) => {\n            Evaluator[key] = evaluator[key];\n        });\n    }\n}\nexports.Evaluator = Evaluator;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/Evaluator.ts?");

/***/ }),

/***/ "./src/utils/dom.ts":
/*!**************************!*\
  !*** ./src/utils/dom.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.empty = exports.removeChildFrom = exports.prependTo = exports.appendTo = void 0;\n/**\n * Append an HTML DOM element to a container.\n *\n * @param element\n * @param container\n */\nfunction appendTo(element, container) {\n    if (container && element) {\n        container === null || container === void 0 ? void 0 : container.appendChild(element);\n    }\n}\nexports.appendTo = appendTo;\n/**\n * Prepend an HTML DOM element to a container.\n *\n * @param {HTMLElement} element - The DOM element to prepend.\n * @param {HTMLElement} container - The DOM element that is the container of the element getting prepended.\n */\nfunction prependTo(element, container) {\n    if (container && element) {\n        if (container.firstChild) {\n            try {\n                container.insertBefore(element, container.firstChild);\n            }\n            catch (err) {\n                console.warn(err);\n                container.appendChild(element);\n            }\n        }\n        else {\n            container.appendChild(element);\n        }\n    }\n}\nexports.prependTo = prependTo;\n/**\n * Removes an HTML DOM element from its bounding container.\n *\n * @param {HTMLElement} element - The element to remove.\n * @param {HTMLElement} container - The DOM element that is the container of the element to remove.\n */\nfunction removeChildFrom(element, container) {\n    if (container && element && container.contains(element)) {\n        try {\n            container.removeChild(element);\n        }\n        catch (err) {\n            console.warn(err);\n        }\n    }\n}\nexports.removeChildFrom = removeChildFrom;\n/**\n * Empty's an HTML DOM element.\n *\n * @param {HTMLElement} element - The element you wish to empty.\n */\nfunction empty(element) {\n    if (element) {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n}\nexports.empty = empty;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/dom.ts?");

/***/ }),

/***/ "./src/utils/sanitize.ts":
/*!*******************************!*\
  !*** ./src/utils/sanitize.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sanitize = void 0;\nconst dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\"));\nlet DOMPurify = null;\nconst getDOMPurify = () => {\n    if (DOMPurify) {\n        return DOMPurify;\n    }\n    if (window) {\n        DOMPurify = (0, dompurify_1.default)(window);\n        return DOMPurify;\n    }\n    return null;\n};\n/**\n * Sanitize an html string.\n *\n * @param string\n * @returns {*}\n */\nfunction sanitize(string, options) {\n    const dompurify = getDOMPurify();\n    if (!dompurify) {\n        console.log('DOMPurify unable to sanitize the contents.');\n        return string;\n    }\n    // Dompurify configuration\n    const sanitizeOptions = {\n        ADD_ATTR: ['ref', 'target', 'within'],\n        USE_PROFILES: { html: true }\n    };\n    // Add attrs\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addAttr) && options.sanitizeConfig.addAttr.length > 0) {\n        options.sanitizeConfig.addAttr.forEach((attr) => {\n            sanitizeOptions.ADD_ATTR.push(attr);\n        });\n    }\n    // Add tags\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addTags) && options.sanitizeConfig.addTags.length > 0) {\n        sanitizeOptions.ADD_TAGS = options.sanitizeConfig.addTags;\n    }\n    // Allow tags\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.allowedTags) && options.sanitizeConfig.allowedTags.length > 0) {\n        sanitizeOptions.ALLOWED_TAGS = options.sanitizeConfig.allowedTags;\n    }\n    // Allow attributes\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.allowedAttrs) && options.sanitizeConfig.allowedAttrs.length > 0) {\n        sanitizeOptions.ALLOWED_ATTR = options.sanitizeConfig.allowedAttrs;\n    }\n    // Allowd URI Regex\n    if (options.sanitizeConfig && options.sanitizeConfig.allowedUriRegex) {\n        sanitizeOptions.ALLOWED_URI_REGEXP = options.sanitizeConfig.allowedUriRegex;\n    }\n    // Allow to extend the existing array of elements that are safe for URI-like values\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addUriSafeAttr) && options.sanitizeConfig.addUriSafeAttr.length > 0) {\n        sanitizeOptions.ADD_URI_SAFE_ATTR = options.sanitizeConfig.addUriSafeAttr;\n    }\n    return dompurify.sanitize(string, sanitizeOptions);\n}\nexports.sanitize = sanitize;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/sanitize.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/base/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});